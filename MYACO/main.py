import math
import numpy as np
from myaco4 import ACO, Graph
import pandas as pd
from share import topN, feature_path, label_path, feature_imp_vec_path
from sklearn.ensemble import RandomForestClassifier
from sklearn import svm
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity
import datetime
from preProcess import allFeature

feature = pd.read_csv(feature_path, sep=' ', header=None).values
label = pd.read_csv(label_path, sep=' ', header=None).values.ravel()
featureImpo = np.zeros((topN, 5))
# 测试使用所有特征进行分类的准确率
def all_features_classifi():

    X_train, X_test, y_train, y_test = train_test_split(feature, label, test_size=0.3)
    # model_rf = RandomForestClassifier()
    model_svm = svm.SVC(kernel='poly', gamma=0.125, C=20)
    # model_rf.fit(X_train, y_train)
    model_svm.fit(X_train, y_train)
    # prediction = model_rf.predict(X_test)
    prediction = model_svm.predict(X_test)
    model_svm.get_params(deep=True)
    print("使用所有特征进行分类的准确率： " + str(accuracy_score(y_test, prediction)) + '\n')
    return accuracy_score(y_test, prediction)


# 生成相似性矩阵
def compute_similarity():
    ImportanceVec = []
    lines = open(feature_imp_vec_path, 'r').readlines()
    out = open(feature_imp_vec_path, 'w')
    for line in lines:
        out.write(str(line.replace('[', '').replace(']', '')))

    lines = open(feature_imp_vec_path, 'r').readlines()
    for line in lines:
        ImportanceVec.append(line.strip())
    # 文件中存的是str，需要将str转float放进数组再重新组成矩阵
    for i in range(len(ImportanceVec)):
        mystr = ImportanceVec[i].split(',')
        for j in range(len(mystr)):
            num = float(mystr[j])
            featureImpo[i][j] = num

    similarity = cosine_similarity(featureImpo)
    print("相似性矩阵计算完成")
    return similarity


def compute_etatable_matrix():
    '''
    生成重要性矩阵，作为启发式信息
    impoAsEtatable[i][j]表示从特征i转移到特征j的启发式信息，也就是j的重要性分数（取平均）
    由于启发式信息取决于目的点，所以其实用一个一维数据就可以（这样其实相当于启发值从边上变成点上）
    0  1  2   3  4
    CS IG SVM RF LR
    '''
    Etatable = [0] * topN
    for i in range(topN):
        # Etatable[i] = featureImpo[i][0]
        Etatable[i] = featureImpo[i][1]
        # Etatable[i] = featureImpo[i][2]
        # Etatable[i] = featureImpo[i][3]
        # Etatable[i] = featureImpo[i][4]
        # Etatable[i] = (featureImpo[i][0] + featureImpo[i][1] + featureImpo[i][2] + featureImpo[i][3] + featureImpo[i][4]) / 5
    print("启发值矩阵计算完成")
    return Etatable


def main():
    similarity = compute_similarity()
    Etatable = compute_etatable_matrix()
    aco = ACO(50, 30, 1.0, 10.0, 0.5, 10, 2, similarity)
    graph = Graph(Etatable)
    path, acc, f1, featureSelectNum, generations = aco.solve(graph)
    return path, acc, f1, featureSelectNum, generations


if __name__ == '__main__':
    start = datetime.datetime.now()
    # initacc = all_features_classifi()
    pathbest, accuary, f1score, SelectNum, gen = main()
    end = datetime.datetime.now()
    # print('使用所有特征进行分类的准确率：{}'.format(initacc))
    print('特征选择后准确率: {}'.format(accuary))
    print('特征选择后f1_score: {}'.format(f1score))

    with open("tmpfile/result", 'a+', encoding="utf-8") as f:
        f.write("featureSelectNum: " + str(SelectNum) + '\n')
        f.write("accuracy: " + str(accuary) + '\n')
        f.write("f1_score: " + str(f1score) + '\n')
        f.write("iter: " + str(gen) + '\n')
        f.write("maintime: " + str((end - start)) + '\n')
        f.write("时间记得要加上tmpfile/impvectime的时间" + '\n')
        # f.write("select these feature: " + '\n')
        # for item in pathbest:
        #     f.write(str(allFeature[int(item)]) + '\n')
        f.write("==========================================================================================" + '\n')
