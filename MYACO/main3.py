# 搭配myaco5使用
import math
import numpy as np
import random
from myaco5 import ACO, Graph
import pandas as pd
from share import topN, feature_path, label_path, feature_imp_vec_path, featureSelectNum, gama
from sklearn.ensemble import RandomForestClassifier
from sklearn import svm
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity
import datetime
from preProcess import allFeature

feature = pd.read_csv(feature_path, sep=' ', header=None).values
label = pd.read_csv(label_path, sep=' ', header=None).values.ravel()
featureImpo = np.zeros((topN, 5))


# 测试使用所有特征进行分类的准确率
def all_features_classifi():

    X_train, X_test, y_train, y_test = train_test_split(feature, label, test_size=0.3)
    # model_rf = RandomForestClassifier()
    model_svm = svm.SVC(kernel='poly', gamma=0.125, C=20)
    # model_rf.fit(X_train, y_train)
    model_svm.fit(X_train, y_train)
    # prediction = model_rf.predict(X_test)
    prediction = model_svm.predict(X_test)
    model_svm.get_params(deep=True)
    print("使用所有特征进行分类的准确率： " + str(accuracy_score(y_test, prediction)) + '\n')
    return accuracy_score(y_test, prediction)


# 生成相似性矩阵
def compute_similarity():
    ImportanceVec = []
    lines = open(feature_imp_vec_path, 'r').readlines()
    out = open(feature_imp_vec_path, 'w')
    for line in lines:
        out.write(str(line.replace('[', '').replace(']', '')))

    lines = open(feature_imp_vec_path, 'r').readlines()
    for line in lines:
        ImportanceVec.append(line.strip())
    # 文件中存的是str，需要将str转float放进数组再重新组成矩阵
    for i in range(len(ImportanceVec)):
        mystr = ImportanceVec[i].split(',')
        for j in range(len(mystr)):
            num = float(mystr[j])
            featureImpo[i][j] = num

    similarity = cosine_similarity(featureImpo)
    print("相似性矩阵计算完成")
    return similarity


def ActivationFunction(a):# tanh Function
        e = 2.671
        expo1 = e ** a
        expo2 = e ** -a
        val = (expo1 - expo2) / (expo1 + expo2)
        return val


def compute_etatable_matrix(similarity):
    eta = np.zeros([5, topN, topN])
    # 计算启发值矩阵
    for i in range(5):
        for j in range(topN):
            for k in range(topN):
                # 使用tanh函数将启发值压缩到[0,1]区间
                # 有些相似度很低的会导致分母变为0，其实就可以当成他们没有相似度，只考虑重要性分数
                if similarity[j][k] ** gama != 0:
                    eta[i][j][k] = ActivationFunction(featureImpo[k][i] / (similarity[j][k] ** gama))
                else:
                    eta[i][j][k] = ActivationFunction(featureImpo[k][i])
    return eta


def update_etatable_weight(weight, five_types_accuracy):
    '''
    每一轮迭代后，根据准确率更新五组启发式信息的权重
    '''
    for i in range(5):
        if five_types_accuracy[i] > 0:
            weight[i] = 0.5 * math.log2(five_types_accuracy[i] / float(1 - five_types_accuracy[i]))
    # 归一化
    sumw = sum(weight)
    for i in range(5):
        weight[i] = weight[i] / sumw
    print("权重数组：")
    print(weight)


def main():
    path = []
    weight = [0.2, 0.2, 0.2, 0.2, 0.2]
    five_types_accuracy = [0.0, 0.0, 0.0, 0.0, 0.0]  # CS IG SVM RF LR
    acc = 0
    f1 = 0
    generations = 0
    similarity = compute_similarity()
    etatable = compute_etatable_matrix(similarity)
    # ant_count, generations, alpha, beta, rho, q, strategy, similarity
    aco = ACO(50, 30, 1.0, 10.0, 0.5, 10, 2, similarity)
    for gen in range(30):
        genstart = datetime.datetime.now()
        update_etatable_weight(weight, five_types_accuracy)
        graph = Graph()
        path, acc, f1, generations, five_types_accuracy = aco.solve(graph, etatable, weight, five_types_accuracy)
        genend = datetime.datetime.now()
        print('第{}代准确率：{}'.format(gen, acc))
        print('第{}代f1_score：{}'.format(gen, f1))
        print('第{}代用时：'.format(gen, genend-genstart))
        print("=============================================")
    return path, acc, f1, generations


if __name__ == '__main__':
    start = datetime.datetime.now()
    # initacc = all_features_classifi()
    pathbest, accuary, f1score, gen = main()
    end = datetime.datetime.now()
    # print('使用所有特征进行分类的准确率：{}'.format(initacc))
    print('特征选择后准确率: {}'.format(accuary))
    print('特征选择后f1_score: {}'.format(f1score))

    with open("tmpfile/result", 'a+', encoding="utf-8") as f:
        f.write("featureSelectNum: " + str(featureSelectNum) + '\n')
        f.write("accuracy: " + str(accuary) + '\n')
        f.write("f1_score: " + str(f1score) + '\n')
        f.write("iter: " + str(gen) + '\n')
        f.write("maintime: " + str((end - start)) + '\n')
        # f.write("时间记得要加上tmpfile/impvectime的时间" + '\n')
        # f.write("select these feature: " + '\n')
        # for item in pathbest:
        #     f.write(str(allFeature[int(item)]) + '\n')
        f.write("==========================================================================================" + '\n')
