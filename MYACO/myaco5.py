'''
更新内容：
启发式信息根据权重动态选择，而不是一直使用平均值
'''
import math
import random
import numpy as np
import pandas as pd
from share import topN, feature_path, label_path, featureSelectNum, select_model
from sklearn.metrics import accuracy_score, f1_score
from sklearn.model_selection import train_test_split
from sklearn import svm
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors.classification import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
import datetime
# from impVec3 import feature, label


feature = pd.read_csv(feature_path, sep=' ', header=None).values
label = pd.read_csv(label_path, sep=' ', header=None).values.ravel()


class Graph(object):
    def __init__(self):
        # 初始化信息素
        self.pheromone = [[1 / (topN / 40) for j in range(topN)] for i in range(topN)]


class ACO(object):
    def __init__(self, ant_count: int, generations: int, alpha: float, beta: float, rho: float, q: int,
                 strategy: int, similarity: np.ndarray):
        """
        :param ant_count:
        :param generations:
        :param alpha: relative importance of pheromone
        :param beta: relative importance of heuristic information
        :param rho: pheromone residual coefficient
        :param q: pheromone intensity
        :param strategy: pheromone update strategy. 0 - ant-cycle, 1 - ant-quality, 2 - ant-density
        :param similarity:相似性矩阵
        """
        self.Q = q
        self.rho = rho
        self.beta = beta
        self.alpha = alpha
        self.ant_count = ant_count
        self.generations = generations
        self.update_strategy = strategy
        self.similarity = similarity


    '''
    计算通过选择的特征来分类的准确率
    根据path中的索引取出featureVec中对应的特征值，喂进分类器
    '''

    def check_accuracy_f1(self, path):
        data_after_feature_selected = []
        for i in path:
            data_after_feature_selected.append(feature[:, i])
        data_after_feature_selected = np.array(data_after_feature_selected)
        data_after_feature_selected = data_after_feature_selected.transpose()  # 矩阵转置
        X_train2, X_test2, y_train2, y_test2 = train_test_split(data_after_feature_selected, label, test_size=0.3)

        if select_model == "SVM":
            model_svm = svm.SVC(kernel='poly', gamma=0.125, C=20)
            model_svm.fit(X_train2, y_train2)
            model_svm.get_params(deep=True)
            prediction2 = model_svm.predict(X_test2)
        elif select_model == "KNN":
            model_knn = KNeighborsClassifier(n_neighbors=1)
            model_knn.fit(X_train2, y_train2)
            model_knn.get_params(deep=True)
            prediction2 = model_knn.predict(X_test2)
        elif select_model == "RF":
            model_rf2 = RandomForestClassifier()
            model_rf2.fit(X_train2, y_train2)
            model_rf2.get_params(deep=True)
            prediction2 = model_rf2.predict(X_test2)
        elif select_model == "LR":
            model_lr2 = LogisticRegression()
            model_lr2.fit(X_train2, y_train2)
            prediction2 = model_lr2.predict(X_test2)
        elif select_model == "DT":
            model_dt = DecisionTreeClassifier()
            model_dt.fit(X_train2, y_train2)
            prediction2 = model_dt.predict(X_test2)

        return accuracy_score(y_test2, prediction2), f1_score(y_test2, prediction2, average='macro')

    '''
    更新信息素
    '''

    def _update_pheromone(self, graph: Graph, ants: list):
        for i, row in enumerate(graph.pheromone):
            for j, col in enumerate(row):
                graph.pheromone[i][j] *= self.rho
                for ant in ants:
                    graph.pheromone[i][j] += ant.pheromone_delta[i][j]

    def solve(self, graph: Graph, etatable, weight, each_type_accuracy):
        best_solution = []
        best_accuracy = 0.0
        best_f1 = 0.0
        ants = [_Ant(self, graph) for i in range(self.ant_count)]
        for ant in ants:
            choice = ant._select_typeof_eta(weight)
            eta = etatable[choice]
            for i in range(featureSelectNum - 1):
                ant._select_next(eta)
            ant.accuracy, ant.f1 = self.check_accuracy_f1(ant.tabu)
            print('局部准确率：{}'.format(ant.accuracy))

            if ant.accuracy > each_type_accuracy[choice]:
                each_type_accuracy[choice] = ant.accuracy

            if ant.accuracy > best_accuracy:
                best_accuracy = ant.accuracy
                best_f1 = ant.f1
                best_solution = [] + ant.tabu
            # update pheromone
            ant._update_pheromone_delta(eta)
        self._update_pheromone(graph, ants)
        return best_solution, best_accuracy, best_f1, self.generations, each_type_accuracy


class _Ant(object):
    def __init__(self, aco: ACO, graph: Graph):
        self.colony = aco
        self.graph = graph
        self.accuracy = 0.0
        self.f1 = 0.0
        self.tabu = []  # 禁忌表，同时也是路径表
        self.pheromone_delta = []  # the local increase of pheromone
        self.allowed = [i for i in range(topN)]  # nodes which are allowed for the next selection
        start = random.randint(0, topN - 1)  # start from any node
        self.tabu.append(start)
        self.current = start
        self.allowed.remove(start)

    def _select_typeof_eta(self, weight):
        choice = 0
        for i in range(20):
            if i == 19:
                choice = 19
            tmpweight = weight[i]
            tmpweight -= random.uniform(0.0, 0.2)
            if tmpweight > 0:
                choice = i
                break
        # if choice == 0:
        #     print("选择CS")
        # if choice == 1:
        #     print("选择IG")
        # if choice == 2:
        #     print("选择SVM")
        # if choice == 3:
        #     print("选择RF")
        # if choice == 4:
        #     print("选择LR")
        return choice

    def _select_next(self, eta):
        denominator = 0  # 分母
        for i in self.allowed:  # \是换行符
            denominator += self.graph.pheromone[self.current][i] ** self.colony.alpha * \
                           eta[self.current][i] ** self.colony.beta
        # print(denominator)

        probabilities = [0 for i in range(topN)]  # probabilities for moving to a node in the next step
        for i in range(topN):
            try:
                # test if allowed list contains i
                self.allowed.index(i)
                probabilities[i] = self.graph.pheromone[self.current][i] ** self.colony.alpha * \
                                       eta[self.current][i] ** self.colony.beta / denominator
            except ValueError:
                pass  # do nothing

        # select next node by probability roulette
        # print(probabilities)
        for i, probability in enumerate(probabilities):
            probability -= np.random.uniform(0.0, 0.01)
            if probability >= 0:
                selected = i
                break
        self.allowed.remove(selected)
        self.tabu.append(selected)
        self.current = selected

    # noinspection PyUnusedLocal
    def _update_pheromone_delta(self, eta):
        self.pheromone_delta = [[0 for j in range(topN)] for i in range(topN)]
        for _ in range(1, len(self.tabu)):
            i = self.tabu[_ - 1]
            j = self.tabu[_]
            if self.colony.update_strategy == 1:  # ant-density system
                self.pheromone_delta[i][j] = self.colony.Q
            elif self.colony.update_strategy == 2:  # ant-quality system
                # noinspection PyTypeChecker
                self.pheromone_delta[i][j] = self.colony.Q * eta[i][j]
            else:  # ant-cycle system
                self.pheromone_delta[i][j] = self.colony.Q * self.accuracy
