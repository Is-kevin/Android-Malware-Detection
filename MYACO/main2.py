# 重要版本留存
import math
import numpy as np
import random
from myaco5 import ACO, Graph
import pandas as pd
from share import topN, feature_path, label_path, feature_imp_vec_path, featureSelectNum
from sklearn.ensemble import RandomForestClassifier
from sklearn import svm
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity
import datetime
from preProcess import allFeature

feature = pd.read_csv(feature_path, sep=' ', header=None).values
label = pd.read_csv(label_path, sep=' ', header=None).values.ravel()
featureImpo = np.zeros((topN, 5))
weight = [0.2, 0.2, 0.2, 0.2, 0.2]

# 测试使用所有特征进行分类的准确率
def all_features_classifi():

    X_train, X_test, y_train, y_test = train_test_split(feature, label, test_size=0.3)
    # model_rf = RandomForestClassifier()
    model_svm = svm.SVC(kernel='poly', gamma=0.125, C=20)
    # model_rf.fit(X_train, y_train)
    model_svm.fit(X_train, y_train)
    # prediction = model_rf.predict(X_test)
    prediction = model_svm.predict(X_test)
    model_svm.get_params(deep=True)
    print("使用所有特征进行分类的准确率： " + str(accuracy_score(y_test, prediction)) + '\n')
    return accuracy_score(y_test, prediction)


# 生成相似性矩阵
def compute_similarity():
    ImportanceVec = []
    lines = open(feature_imp_vec_path, 'r').readlines()
    out = open(feature_imp_vec_path, 'w')
    for line in lines:
        out.write(str(line.replace('[', '').replace(']', '')))

    lines = open(feature_imp_vec_path, 'r').readlines()
    for line in lines:
        ImportanceVec.append(line.strip())
    # 文件中存的是str，需要将str转float放进数组再重新组成矩阵
    for i in range(len(ImportanceVec)):
        mystr = ImportanceVec[i].split(',')
        for j in range(len(mystr)):
            num = float(mystr[j])
            featureImpo[i][j] = num

    similarity = cosine_similarity(featureImpo)
    print("相似性矩阵计算完成")
    return similarity


def compute_etatable_matrix(weight, lastchoice, acc):
    '''
    生成重要性矩阵，作为启发式信息
    impoAsEtatable[i][j]表示从特征i转移到特征j的启发式信息，根据acc调整选择的启发信息
    由于启发式信息取决于目的点，所以其实用一个一维数据就可以（这样其实相当于启发值从边上变成点上）
    0  1  2   3  4
    CS IG SVM RF LR
    '''
    choice = 0
    if lastchoice > 0:
        print(acc)
        weight[lastchoice] = 0.5 * math.log2(acc / float(1 - acc))
    print("权重数组：")
    print(weight)
    weight2 = weight
    for i in range(5):
        if i == 4:
            choice = 4
        weight2[i] -= random.random() / 5
        if weight2[i] > 0:
            choice = i
            break
    if choice == 0:
        print("选择CS")
    if choice == 1:
        print("选择IG")
    if choice == 2:
        print("选择SVM")
    if choice == 3:
        print("选择RF")
    if choice == 4:
        print("选择LR")
    Etatable = [0] * topN
    for i in range(topN):
        Etatable[i] = featureImpo[i][choice]
    print("启发值矩阵计算完成")
    return choice, Etatable


def main():
    path = []
    acc = 0
    f1 = 0
    generations = 0
    similarity = compute_similarity()
    aco = ACO(50, 30, 1.0, 10.0, 0.5, 10, 2, similarity)
    lastchoice = -1
    for gen in range(30):
        genstart = datetime.datetime.now()
        lastchoice, Etatable = compute_etatable_matrix(weight, lastchoice, acc)
        graph = Graph()
        path, acc, f1, generations = aco.solve(graph)
        genend = datetime.datetime.now()
        print('第{}代准确率：{}'.format(gen, acc))
        print('第{}代f1_score：{}'.format(gen, f1))
        print('第{}代用时：'.format(genend-genstart))
        print("=============================================")
    return path, acc, f1, generations


if __name__ == '__main__':
    start = datetime.datetime.now()
    # initacc = all_features_classifi()
    pathbest, accuary, f1score, gen = main()
    end = datetime.datetime.now()
    # print('使用所有特征进行分类的准确率：{}'.format(initacc))
    print('特征选择后准确率: {}'.format(accuary))
    print('特征选择后f1_score: {}'.format(f1score))

    with open("tmpfile/result", 'a+', encoding="utf-8") as f:
        f.write("featureSelectNum: " + str(featureSelectNum) + '\n')
        f.write("accuracy: " + str(accuary) + '\n')
        f.write("f1_score: " + str(f1score) + '\n')
        f.write("iter: " + str(gen) + '\n')
        f.write("maintime: " + str((end - start)) + '\n')
        f.write("时间记得要加上tmpfile/impvectime的时间" + '\n')
        # f.write("select these feature: " + '\n')
        # for item in pathbest:
        #     f.write(str(allFeature[int(item)]) + '\n')
        f.write("==========================================================================================" + '\n')
