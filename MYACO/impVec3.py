'''
功能：
使用featureVec文件和label文件fit分类器，获取在不同分类器中该特征的重要性分数，拼接成重要性向量
最终将每个特征及其重要性向量保存到impVec文件中
对特征按照重要性分数进行排序，预筛选
'''
import csv
import numpy as np
import pandas as pd
import datetime
from sklearn import svm
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import chi2
from sklearn.feature_selection import mutual_info_classif
# from preProcess import featureNum, preprocesstime
from share import topN, allFeatureSetPath, feature_path, label_path, feature_imp_vec_path, topn_feature_vec_path

start = datetime.datetime.now()
allFeature = []  # 所有特征的list
lines = csv.reader(open(allFeatureSetPath, encoding='utf-8'))
for line in lines:
    allFeature.append(line[0].strip())
featureNum = len(allFeature)

# 重要性向量
impVec = []
# 重要性分数
score_cs = [0]*featureNum
score_IG = [0]*featureNum

score_svm = [0]*featureNum
score_rf = [0]*featureNum
score_lr = [0]*featureNum

score_mean = [0]*featureNum

feature = pd.read_csv(feature_path, sep=' ', header=None).values
label = pd.read_csv(label_path, sep=' ', header=None).values.ravel()


model_cs = SelectKBest(chi2, k=topN)
model_cs.fit(feature, label)

model_IG = SelectKBest(mutual_info_classif, k=topN)
model_IG.fit(feature, label)

model_svm = svm.SVC(kernel='linear')
model_svm.fit(feature, label)

model_rf = RandomForestClassifier()
model_rf.fit(feature, label)

model_lr = LogisticRegression()
model_lr.fit(feature, label)

# 重要性评分
for i in range(featureNum):
    score_cs[i] = (model_cs.scores_.ravel()[i] - model_cs.scores_.ravel().min()) / (
              model_cs.scores_.ravel().max() - model_cs.scores_.ravel().min())
    score_IG[i] = (model_IG.scores_.ravel()[i] - model_IG.scores_.ravel().min()) / (
              model_IG.scores_.ravel().max() - model_IG.scores_.ravel().min())

    score_svm[i] = (model_svm.coef_.ravel()[i] - model_svm.coef_.ravel().min()) / (
              model_svm.coef_.ravel().max() - model_svm.coef_.ravel().min())
    score_rf[i] = (model_rf.feature_importances_.ravel()[i] - model_rf.feature_importances_.ravel().min()) / (
            model_rf.feature_importances_.ravel().max() - model_rf.feature_importances_.ravel().min())
    score_lr[i] = (model_lr.coef_.ravel()[i] - model_lr.coef_.ravel().min()) / (
            model_lr.coef_.ravel().max() - model_lr.coef_.ravel().min())

    score_mean[i] = (score_cs[i] + score_IG[i] + score_svm[i] + score_rf[i] + score_lr[i]) / 5

# 重要性排序
idx = sorted(enumerate(score_mean), key=lambda x: x[1], reverse=True)
# 返回topN的特征的索引
top = np.array([idx[i][0] for i in range(topN)])

# topN特征重要性分数拼接成重要性向量
for i in range(topN):
    tmp = [score_cs[top[i]], score_IG[top[i]], score_svm[top[i]], score_rf[top[i]], score_lr[top[i]]]
    impVec.append(tmp)

# 生成topN重要性向量文件
with open(feature_imp_vec_path, 'w+', encoding="utf-8") as f:
    for vec in impVec:
        f.write(str(vec) + '\n')

# 生成topN特征向量文件
feature = feature[:][:, top]
with open(topn_feature_vec_path, 'w+', encoding="utf-8") as f:
    for vec in feature:
        f.write(str(vec) + '\n')

end = datetime.datetime.now()
# impvectime = end - start + preprocesstime
impvectime = end - start
with open("tmpfile/impvectime", 'w+', encoding="utf-8") as f:
    f.write(str(impvectime))