import numpy as np
import pandas as pd
from sklearn import svm
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
# from impVec3 import feature, label, impvectime
from share import feature_path, label_path
import datetime

feature = pd.read_csv(feature_path, sep=' ', header=None).values
label = pd.read_csv(label_path, sep=' ', header=None).values.ravel()
print("读取feature和label结束")

DNA_SIZE = 12
FEATURE_NUM = 1000
POP_SIZE = 5000
CROSSOVER_RATE = 0.8
MUTATION_RATE = 0.005
N_GENERATIONS = 50
BOUND = [0, 1]


def classmodel(data_after_feature_selected):
    X_train, X_test, y_train, y_test = train_test_split(data_after_feature_selected, label, test_size=0.3)
    model_svm = svm.SVC(kernel='poly', gamma=0.125, C=20)
    model_svm.fit(X_train, y_train)
    model_svm.get_params(deep=True)
    prediction = model_svm.predict(X_test)
    return accuracy_score(y_test, prediction)


def get_fitness(pop):
    fitnezz = []
    selectpop = translateDNA(pop)
    for population in selectpop:
        data_after_feature_selected = []
        for i in range(len(population)):
            if population[i] >= 0.5:
                data_after_feature_selected.append(feature[:, i])
        data_after_feature_selected = np.array(data_after_feature_selected)
        data_after_feature_selected = data_after_feature_selected.transpose()  # 矩阵转置
        acc = classmodel(data_after_feature_selected)
        fitnezz.append(acc)
    return (fitnezz - np.min(fitnezz)) + 1e-3
    # 减去最小的适应度是为了防止适应度出现负数，通过这一步fitness的范围为[0, np.max(pred)-np.min(pred)],最后在加上一个很小的数防止出现为0的适应度


def get_fitness2(pop):
    fitnezz = []
    selectpop = translateDNA(pop)
    for population in selectpop:
        data_after_feature_selected = []
        for i in range(len(population)):
            if population[i] >= 0.5:
                data_after_feature_selected.append(feature[:, i])
        data_after_feature_selected = np.array(data_after_feature_selected)
        data_after_feature_selected = data_after_feature_selected.transpose()  # 矩阵转置
        acc = classmodel(data_after_feature_selected)
        fitnezz.append(acc)
    return fitnezz
    # 减去最小的适应度是为了防止适应度出现负数，通过这一步fitness的范围为[0, np.max(pred)-np.min(pred)],最后在加上一个很小的数防止出现为0的适应度


# 解码
def translateDNA(pop):  # pop表示种群矩阵，一共POP_SIZE个矩阵，一行表示一个二进制编码表示的DNA，矩阵的行数为特征数目
    selectpop = []
    for population in pop:
        tmppop = population
        tmppop = tmppop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * (BOUND[1] - BOUND[0]) + BOUND[
            0]
        selectpop.append(tmppop)
    return selectpop


def crossover_and_mutation(pop, CROSSOVER_RATE=0.8):
    new_pop = []
    for father in pop:  # 遍历种群中的每一个个体，将该个体作为父亲
        child = father  # 孩子先得到父亲的全部基因（这里我把一串二进制串的那些0，1称为基因）
        if np.random.rand() < CROSSOVER_RATE:  # 产生子代时不是必然发生交叉，而是以一定的概率发生交叉
            mother = pop[np.random.randint(POP_SIZE)]  # 再种群中选择另一个个体，并将该个体作为母亲
            cross_points = np.random.randint(low=0, high=DNA_SIZE * 2)  # 随机产生交叉的点
            child[cross_points:] = mother[cross_points:]  # 孩子得到位于交叉点后的母亲的基因
        mutation(child)  # 每个后代有一定的机率发生变异
        new_pop.append(child)

    return new_pop


def mutation(child, MUTATION_RATE=0.003):
    if np.random.rand() < MUTATION_RATE:  # 以MUTATION_RATE的概率进行变异
        mutate_point = np.random.randint(0, DNA_SIZE)  # 随机产生一个实数，代表要变异基因的位置
        child[mutate_point] = child[mutate_point] ^ 1  # 将变异点的二进制为反转


def select(pop, fitness):  # nature selection wrt pop's fitness
    idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True,
                           p=(fitness) / (fitness.sum()))
    return pop[idx]


def print_info(pop):
    fitness = get_fitness2(pop)
    max_fitness_index = np.argmax(fitness)
    print("最高准确率:", fitness[max_fitness_index])
    selectpop = translateDNA(pop)
    cnt = 0
    for item in selectpop[max_fitness_index]:
        if item >= 0.5:
            cnt += 1
    print("选择特征个数：", cnt)


if __name__ == "__main__":
    start = datetime.datetime.now()
    # POP_SIZE个matrix，matrix的行是特征，列是基因
    pop = np.random.randint(2, size=(POP_SIZE, FEATURE_NUM, DNA_SIZE))  # matrix (POP_SIZE, FEATURE_NUM, DNA_SIZE)
    for _ in range(N_GENERATIONS):  # 迭代N代
        genstart = datetime.datetime.now()
        pop = np.array(crossover_and_mutation(pop, CROSSOVER_RATE))
        fitness = get_fitness(pop)
        pop = select(pop, fitness)  # 选择生成新的种群
        genend = datetime.datetime.now()
        print('第{}代用时: {}'.format(_, genend-genstart))

    print_info(pop)

    end = datetime.datetime.now()
    print("用时：" + str((end - start)))


