'''
更新内容：
将特征去冗余这部分工作融合进蚁群公式里而不是单独出来
'''
import random
import numpy as np
import pandas as pd
from share import topN, feature_path, label_path
from sklearn.metrics import accuracy_score, f1_score
from sklearn.model_selection import train_test_split
from sklearn import svm
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors.classification import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
import datetime
from impVec3 import feature, label
# 忽略分母可能为0的warning
# np.seterr(invalid='ignore')

# feature = pd.read_csv(feature_path, sep=' ', header=None).values
# label = pd.read_csv(label_path, sep=' ', header=None).values.ravel()

class Graph(object):
    def __init__(self, cost_matrix: list):
        """
        :param cost_matrix: 启发值矩阵
        """
        self.matrix = cost_matrix
        # 初始化信息素
        self.pheromone = [[1 / (topN / 40) for j in range(topN)] for i in range(topN)]


class ACO(object):
    def __init__(self, ant_count: int, generations: int, alpha: float, beta: float, rho: float, q: int,
                 strategy: int, similarity: np.ndarray):
        """
        :param ant_count:
        :param generations:
        :param alpha: relative importance of pheromone
        :param beta: relative importance of heuristic information
        :param rho: pheromone residual coefficient
        :param q: pheromone intensity
        :param strategy: pheromone update strategy. 0 - ant-cycle, 1 - ant-quality, 2 - ant-density
        :param similarity:相似性矩阵
        """
        self.Q = q
        self.rho = rho
        self.beta = beta
        self.alpha = alpha
        self.ant_count = ant_count
        self.generations = generations
        self.update_strategy = strategy
        self.similarity = similarity
        self.featureSelectNum = 100

    '''
    计算通过选择的特征来分类的准确率
    根据path中的索引取出featureVec中对应的特征值，喂进分类器
    '''

    def check_accuracy_f1(self, path):
        data_after_feature_selected = []
        for i in path:
            data_after_feature_selected.append(feature[:, i])
        data_after_feature_selected = np.array(data_after_feature_selected)
        data_after_feature_selected = data_after_feature_selected.transpose()  # 矩阵转置
        X_train2, X_test2, y_train2, y_test2 = train_test_split(data_after_feature_selected, label, test_size=0.3)

        model_svm = svm.SVC(kernel='poly', gamma=0.125, C=20)
        model_svm.fit(X_train2, y_train2)
        model_svm.get_params(deep=True)
        prediction2 = model_svm.predict(X_test2)

        # model_knn = KNeighborsClassifier(n_neighbors=1)
        # model_knn.fit(X_train2, y_train2)
        # model_knn.get_params(deep=True)
        # prediction2 = model_knn.predict(X_test2)

        # model_rf2 = RandomForestClassifier()
        # model_rf2.fit(X_train2, y_train2)
        # model_rf2.get_params(deep=True)
        # prediction2 = model_rf2.predict(X_test2)

        # model_lr2 = LogisticRegression()
        # model_lr2.fit(X_train2, y_train2)
        # prediction2 = model_lr2.predict(X_test2)

        # model_dt = DecisionTreeClassifier()
        # model_dt.fit(X_train2, y_train2)
        # prediction2 = model_dt.predict(X_test2)

        return accuracy_score(y_test2, prediction2), f1_score(y_test2, prediction2, average='macro')

    '''
    更新信息素
    '''

    def _update_pheromone(self, graph: Graph, ants: list):
        for i, row in enumerate(graph.pheromone):
            for j, col in enumerate(row):
                graph.pheromone[i][j] *= self.rho
                for ant in ants:
                    graph.pheromone[i][j] += ant.pheromone_delta[i][j]

    def solve(self, graph: Graph):
        best_solution = []
        best_accuracy = 0.0
        best_f1 = 0.0
        redundantNum = 0
        for gen in range(self.generations):
            # noinspection PyUnusedLocal
            genstart = datetime.datetime.now()
            ants = [_Ant(self, graph) for i in range(self.ant_count)]
            for ant in ants:
                for i in range(self.featureSelectNum - 1):
                    ant._select_next()
                ant.accuracy, ant.f1 = self.check_accuracy_f1(ant.tabu)
                print('局部准确率：{}'.format(ant.accuracy))
                if ant.accuracy > best_accuracy:
                    best_accuracy = ant.accuracy
                    best_f1 = ant.f1
                    best_solution = [] + ant.tabu
                # update pheromone
                ant._update_pheromone_delta()
            self._update_pheromone(graph, ants)
            genend = datetime.datetime.now()
            print('第{}代用时：{}'.format(gen, (genend - genstart)))
            print('第{}代准确率：{}'.format(gen, best_accuracy))
            print('第{}代f1_score：{}'.format(gen, best_f1))
            print("=============================================")
        return best_solution, best_accuracy, best_f1, self.featureSelectNum, self.generations


class _Ant(object):
    def __init__(self, aco: ACO, graph: Graph):
        self.colony = aco
        self.graph = graph
        self.accuracy = 0.0
        self.f1 = 0.0
        self.tabu = []  # 禁忌表，同时也是路径表
        self.pheromone_delta = []  # the local increase of pheromone
        self.allowed = [i for i in range(topN)]  # nodes which are allowed for the next selection
        self.eta = graph.matrix  # heuristic information
        start = random.randint(0, topN - 1)  # start from any node
        self.tabu.append(start)
        self.current = start
        self.allowed.remove(start)


    def _select_next(self):
        denominator1 = 0  # 分母
        for i in self.allowed:  # \是换行符
            denominator1 += self.graph.pheromone[self.current][i] ** self.colony.alpha * \
                           self.eta[i] ** self.colony.beta
        denominator2 = []  # 冗余性分母
        for i in self.allowed:
            tmp = 0
            for j in self.tabu:
                tmp = max(tmp, self.colony.similarity[j][i])
            denominator2.append(tmp)
        # print(denominator2)


        probabilities = [0 for i in range(topN)]  # probabilities for moving to a node in the next step
        for i in range(topN):
            try:
                # test if allowed list contains i
                temp = denominator2[self.allowed.index(i)]
                if temp == 0:
                    probabilities[i] = self.graph.pheromone[self.current][i] ** self.colony.alpha * \
                                       self.eta[i] ** self.colony.beta / denominator1
                else:
                    probabilities[i] = self.graph.pheromone[self.current][i] ** self.colony.alpha * \
                                   self.eta[i] ** self.colony.beta / (denominator1 * temp * 10)
            except ValueError:
                pass  # do nothing

        # select next node by probability roulette
        for i, probability in enumerate(probabilities):
            probability -= np.random.rand() / 100
            if probability >= 0:
                selected = i
                break
        self.allowed.remove(selected)
        self.tabu.append(selected)
        self.current = selected

    # noinspection PyUnusedLocal
    def _update_pheromone_delta(self):
        self.pheromone_delta = [[0 for j in range(topN)] for i in range(topN)]
        for _ in range(1, len(self.tabu)):
            i = self.tabu[_ - 1]
            j = self.tabu[_]
            if self.colony.update_strategy == 1:  # ant-density system
                self.pheromone_delta[i][j] = self.colony.Q
            elif self.colony.update_strategy == 2:  # ant-quality system
                # noinspection PyTypeChecker
                self.pheromone_delta[i][j] = self.colony.Q * self.graph.matrix[j]
            else:  # ant-cycle system
                self.pheromone_delta[i][j] = self.colony.Q * self.accuracy
