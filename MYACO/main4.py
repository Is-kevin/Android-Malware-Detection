'''
用于测试5个分类器对应5中单一的启发值信息
'''

import math
import numpy as np
import random
from myaco6 import ACO, Graph
import pandas as pd
from share import topN, feature_path, label_path, feature_imp_vec_path, featureSelectNum, gama
from sklearn.ensemble import RandomForestClassifier
from sklearn import svm
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity
import datetime

feature = pd.read_csv(feature_path, sep=' ', header=None).values
label = pd.read_csv(label_path, sep=' ', header=None).values.ravel()
featureImpo = np.zeros((topN, 5))


# 生成相似性矩阵
def compute_similarity():
    ImportanceVec = []
    lines = open(feature_imp_vec_path, 'r').readlines()
    out = open(feature_imp_vec_path, 'w')
    for line in lines:
        out.write(str(line.replace('[', '').replace(']', '')))

    lines = open(feature_imp_vec_path, 'r').readlines()
    for line in lines:
        ImportanceVec.append(line.strip())
    # 文件中存的是str，需要将str转float放进数组再重新组成矩阵
    for i in range(len(ImportanceVec)):
        mystr = ImportanceVec[i].split(',')
        for j in range(len(mystr)):
            num = float(mystr[j])
            featureImpo[i][j] = num

    similarity = cosine_similarity(featureImpo)
    print("相似性矩阵计算完成")
    return similarity


def ActivationFunction(a):
    e = 2.671
    expo1 = e ** a
    expo2 = e ** -a
    val = (expo1 - expo2) / (expo1 + expo2)
    return val


def compute_etatable_matrix(similarity):
    # eta = np.zeros([5, topN, topN])
    eta = np.zeros([topN, topN])

    for j in range(topN):
        for k in range(topN):
            # 调节featureImpo[k][0]到featureImpo[k][4]为单独使用5种分数，丑陋的硬编码
            if similarity[j][k] ** gama != 0:
                eta[j][k] = ActivationFunction(featureImpo[k][4] / (similarity[j][k] ** gama))
            else:
                eta[j][k] = ActivationFunction(featureImpo[k][4])

    return eta


def main():
    path = []
    bestpath = []
    acc4plt = []
    bestacc = 0
    acc = 0
    f1 = 0
    generations = 0
    similarity = compute_similarity()
    etatable = compute_etatable_matrix(similarity)
    # ant_count, generations, alpha, beta, rho, q, strategy, similarity
    aco = ACO(100, 200, 1.0, 10.0, 0.5, 10, 3, similarity)
    for gen in range(200):
        genstart = datetime.datetime.now()
        graph = Graph()
        path, acc, f1, generations = aco.solve(graph, etatable)
        if acc > bestacc:
            bestacc = acc
            bestpath = path
        acc4plt.append(bestacc)
        genend = datetime.datetime.now()
        print('第{}代准确率：{}'.format(gen, acc))
        print('第{}代f1_score：{}'.format(gen, f1))
        print('第{}代用时：{}'.format(gen, genend - genstart))
        print("=============================================")
    return bestpath, bestacc, f1, acc4plt


if __name__ == '__main__':
    start = datetime.datetime.now()
    pathbest, accuary, f1score, acc4plt = main()
    print('特征选择后准确率: {}'.format(accuary))
    print('特征选择后f1_score: {}'.format(f1score))
    end = datetime.datetime.now()
    with open("tmpfile/result2", 'a+', encoding="utf-8") as f:
        f.write("featureSelectNum: " + str(featureSelectNum) + '\n')
        f.write("accuracy: " + str(accuary) + '\n')
        f.write("f1_score: " + str(f1score) + '\n')
        f.write('lr_accarray: {}'.format(acc4plt) + '\n')
        f.write("maintime: " + str((end - start)) + '\n')
        f.write("==========================================================================================" + '\n')